# wargaming-test-intern
Тестовое задание на позицию Programming intern в компании Wargaming Санкт-Петербург

ЗАДАНИЕ №1 ( ОБЯЗАТЕЛЬНО К ВЫПОЛНЕНИЮ)          
На языке Python или С/С++, написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути.
                Объяснить плюсы и минусы обеих реализаций.
                Python example:
                def isEven(value):return value%2==0
                C/C++ example:
                bool isEven(int value){return value%2==0;}

РЕШЕНИЕ Задания 1:
С++
//Функция проверки четнсти элемента из Задания№1
void isEven(int value) {
    return value % 2 == 0;
}
//Улучшенный вариант функции проверки четности элемента. Использует бинарное умножение.
// Поскольку нечетные числа в двоичной системе всегда оканчиваются 1, то при бинарном умножении числа на 1 нечетное число будет равно 1, а четное 0.
void isEvenNew(int value) {
    return !(value&1);
}

Python

def isEven(value): #Первый вариант. Изначальный
    return( value%2==0)

def isEvenNew(value): #Улучшенный вариант
    return( not value&1)

Если необходимо проверить четность элементов массива, то улучшенный вариант позволит быстрее его обработать. Внизу представлено время обработки массива из 10000 элементов.  
Улучшенный метод быстрее.



Задание № 2. (Обязательно к выполнению).            
На языках Python(2.7) и/или С++, написать минимум по 2 класса реализовывающих циклический буфер FIFO.
                Объяснить плюсы и минусы каждой реализации.
                
Решение задания №2 С++ Первый класс на основе стат. массива
Решение Задания №2 С++ Второй класс на основе динамического массива



Решение задания №2. С++ Плюсы и минусы



Динамическое выделение памяти по сравнению со статическим выделением памяти дает следующие преимущества:
⦁	память выделяется по мере необходимости программным путем;
⦁	нет лишних затрат неиспользованной памяти. Выделяется столько памяти сколько нужно и если нужно;
⦁	можно выделять память для массивов информации, размер которых заведомо неизвестен. Определение размера массива формируется в процессе выполнения программы;
⦁	удобно осуществлять перераспределение памяти. Или другими словами, удобно выделять новый фрагмент для одного и того же массива, если нужно выделить дополнительную память или освободить ненужную;
⦁	при статическом способе выделения памяти трудно перераспределять память для переменной-массива, поскольку она уже выделена фиксировано. В случае динамического способа выделения, это делается просто и удобно.

Преимущества статического способа выделения памяти:
⦁	статическое (фиксированное) выделение памяти лучше использовать, когда размер массива информации заведомо известен и есть неизменным на протяжении выполнения всей программы;
⦁	статическое выделение памяти не требует дополнительных операций освобождения с помощью оператора delete. Отсюда вытекает уменьшение ошибок программирования. Каждому оператору new должен соответствовать свой оператор delete;
⦁	естественность (натуральность) представления программного кода, который оперирует статическими массивами.



Решение задания №2 Python


К сожалению, не смогла написать второй класс на Python. Но по сравнению с С++, реализация (написание кода) быстрее, объем программы тоже меньше.


Задание № 3. (Дополнительно, будет бонусом).           
На языке Python или С/С++, написать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел.
                Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным).
                Объяснить почему вы считаете, что функция соответствует заданным критериям.

Решение задания №3  Алгоритм и результаты

	Для решения данной задачи ярешила использовать сортировку Timsort.
Timsort — гибридный алгоритм сортировки, сочетающий сортировку вставками и сортировку слиянием.
Сортировка вставками более эффективна на небольших массивах. В моей реализации – массивы не более 64 элемента.


	Описание алгоритма:
⦁	Сортировка вставками:
⦁	Разбиение исходного массива на подмассивы размером не более 64 элемента с проверкой – отсортирован ли подмассив изначально
⦁	если подмассив не отсортирован, то сортировка вставками
⦁	Сортировка слиянием, если размеры исходного массива больше 64 элементов и массив не был отсротирован с самого начала, то:
2.1 если подмассивов больше 1,то происходит слияние первого и второго подмассивов в первый подмассив с удалением второго подмассива. Иначе, первый подмассив – отсортированный исходный массив.

Результаты работы алгоритма на С++ и Python представлены ниже,
С++. Указана длина массива, время в сек и тактах при сортировке не отсортированного и отсортированного массива соответственно.
  .   

Результаты на языке Python . Длина массива и время сортировки исходного неотсортированного и отсортированного массивов соответственно
 

В результате  - изначально отсортированный массив обрабатывается за короткое время. Но на Python  он обрабатывается немного быстрее, но неупорядоченный изначально массив на С++ обрабатывается в разы быстрее. 

Алгоритм в С++ и Python одинаковый. Извините, но комментарии есть только к С++. Очень устала)

