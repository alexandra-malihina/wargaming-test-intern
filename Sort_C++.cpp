// sort.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <ctime>
#include <string>
#include <vector>

const clock_t start = clock();// начало работы программы
static int minRun = 0; // минимальный размер подмассива для слияния
int length; // длина входного массива

//Время выполнения программы с самого начала до текущего момента
double  Duration_sec() {
    return static_cast<double>(clock() - start) / CLOCKS_PER_SEC;
}

//Время выполнения программы с самого начала до текущего момента
clock_t  Duration() {
    return (clock() - start);
}
void writeComment(std::string str) // функция вывода комментария
{
    std::cout << "\n\n######################################" << std::endl;
    std::cout << str << "\n\n" << std::endl;
}

void minRunLength() { // функция расчета минимального размера массива для вставки
    int flag = 0; // если входной массив меньше 64, то он не будет разбит на подмассивы, а просто произойдет сортировка вставками, без слияния
    int n = length;
    while (n >= 64) {
        flag |= n & 1; //или с присваиванием
        n >>= 1; // побитовый сдвиг вправо на 1
    }
    minRun = n + flag;
}


void print(int* array, std::string text) // функция для вывода ммассива
{
    writeComment(text);
    for (int i = 0; i < length; i++)
    {
        std::cout << array[i] << " ";
    }
    std::cout << "\n\n";
    
}

void merge(std::vector<std::vector<int> >&run, int* array) { //функция для слияния отсортированных подмассивов
   
    int runSize = run.size();
    while (runSize>0) { //при слиянии двух подмассивов удаляет один из них, поэтому пока есть что слиять слияем
       
        if (runSize > 1)
        {
            //слияются первые два подмассива
            int runElSize = run[0].size(); 
            
            for (int i = 0; i < runElSize; i++) {
                if (!run[1].empty()) {// если есть второй подмассив,то слияем с первым
                    if (run[1][0] < run[0][i]) { // если во втором массиве первый элемент меньше текущего элемента в первом подмассиве, то вставляем егоперед ним
                        run[0].insert(run[0].begin() + i, run[1][0]);
                        run[1].erase(run[1].begin());// удаляем этот элемент из второго подмассива
                        runElSize++; // увеличиваем переменную с количесвтом элементов в первом подмассиве на единицу
                    }
                }
                else break;
           
            }
            if (!run[1].empty()) { // если второй подмассив после прохождения всего первого подмассива оказался не пуствм,то вставляем этот подмассив в конец первого подмассива
                run[0].insert(run[0].end(), run[1].begin(), run[1].end());
            }
            run[1].clear(); // очищаем и удаляем второй подмассив
            run.erase(run.begin() + 1);
            runSize--;
        }
        else {
            //когда остается один подмасиив - все подмассивы слились в один, то записываем новые значения в начальный массив
            for (int i = 0; i < length; i++) {
                array[i] = run[0][i];
            }
            run.clear();
            runSize = 0;
        }
    }
}

void sort(std::vector<int> &run) { // функция сортировки подмассива с помощью вставки
    bool sorted = false; // переменная - отсортирован ли массив уже или нет
    int i = 0; // индекс текущего элемента
    int sortedEl = 0; // количесвто отсортированных элементов за один проход
    int runSize = run.size()-1;
   
    while (sorted != true) {
        
        if (run[i] > run[i + 1]) { //если стоит поменять элементы местами, то меняем
            int p = run[i + 1];           
            run[i + 1] = run[i];
            run[i] = p;
            sortedEl++; //увеличиваем количество отсортированных элементов        
        }            
        i++;
        if (i == runSize) // если достиглт конца подмассива, то 
        {
            i =0;
            
            if (sortedEl == 0) // если не было перестановок - подмассив отсортирован
                sorted = true;
            else
                sortedEl = 0; // продолжаем сортировку
        }
        
    } 

   

}

void TimSort(int* array) {
    clock_t duration_t = Duration(); // переменные для проверки вермени сортировки
    double duration_sec = Duration_sec();
    
    int minRun_1 = minRun - 1; // дополнительные переменные, чтобы не рассчитывать их каждый раз в цикле
    int length_1 = length - 1;
    std::vector<std::vector<int> >run(1); // вектор, содержащий вектора - подмассивы
    int indexVector = 0; // индекс текущего заполняемого вектора
    bool sorted = true; // переменная - отсортирован ли подмассив
    int sortedMas = 0; // переменная, содеражащая количество отсортированных изначально  подмассивов ( с самого первого)

    for (int i = 0; i < length; i++) {
        if (run[indexVector].size() == 0) { //если текущий вектор пуст, то просто вставляем туда элемент
            sorted = true; // считаем этот подмассив отсортированным
            run[indexVector].push_back(array[i]);
            if (i > 0 && array[i-1] > array[i]) // если в предыдущем подмассиве последний элемент больше текущего -значит эти подмассивы не отсортированы 
                sortedMas--;
        }
        else {
            if (run[indexVector].size() == minRun_1 || i == length_1) { //если заполнен подмассив или кончился входной массив,то
             
                    if (run[indexVector].back() > array[i]) { //если последний элемент входного массива меньше последнего, то подмассив не отсортирован
                        sorted = false;
                    }
                    run[indexVector].push_back(array[i]); // вставляем последний элемент

                    if (!sorted) {

                        sort(run[indexVector]); // если подмассив не отсортирован, то производим сортировку вставками
                       
                    }
                       
                    else
                        sortedMas++; // иначе увеличиваем количество отсортированных изначально массивов
                if (i < length_1) //если не дошли до конца входног массива,то
                {
                    indexVector++; //добавляем новый подмассив
                    run.push_back(std::vector<int>());
                }
            }
            else {//иначе
                if (run[indexVector].back() > array[i]) {// если последний элемент подмассива больше вставляемого из изначального - подмассив неотсортирован
                    sorted = false;
                }
                run[indexVector].push_back(array[i]); // вставляем в конец подмассива новый элемент
            }
        }
    }

    if (sortedMas!=run.size()) { //если массив не отсортирован изначально и количество элементов в исходном массиве меньше 64
        merge(run,array);//производим слияние подмассивов
    } 
    

    std::cout << "\n duration sec-" << Duration_sec() - duration_sec << std::endl;
    std::cout << "\n duration tact-" << Duration() - duration_t << std::endl;
}

int main()
{

    std::cout << "Set array length\n";
    std::cin >> length;// ввод размера входного массива

    int* arrayRand = new int[length]; // входной массив. не отсортированный изначально
    int* arraySort = new int[length]; // входной массив . отсортированный изначально

    for (int i = 0; i < length; i++) // заполнение входных массивов
    {
        arrayRand[i] = rand() % 10; //заполнение не осортированного массива случайными значениями
        arraySort[i] = i; //заполнение отсортированного массива
    }

   // print(arrayRand, "Rand Array");
   // print(arraySort, "Sort Array");
    std::cout << std::endl;

    minRunLength();// расчет мминимального размера массива для сортировки слиянием
    //Сортировка массивов
    TimSort(arrayRand);
    TimSort(arraySort);

   // print(arrayRand, "Rand Array After Sorting");
   // print(arraySort, "Sort Array After Sorting");

    delete[] arraySort;
    delete[] arrayRand;
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
